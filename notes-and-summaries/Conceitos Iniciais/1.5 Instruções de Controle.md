## Estrutura Condicional IF

Em uma estrutura condicional *if*, a condi√ß√£o sempre retornar√° um valor booleano. Se a condi√ß√£o for verdadeira, a instru√ß√£o ser√° executada, caso contr√°rio ser√° ignorada.

```java
if(condi√ß√£o){
	sequ√™ncia de instru√ß√µes
}
```

## Estrutura Condicional IF-ELSE

A cl√°usula *else* √© opcional. Se a express√£o condicional for verdadeira, o alvo de if ser√° executado, caso contr√°rio, se houver, o alvo de else ser√° executado. Nunca ambos ser√£o executados. A express√£o condicional que controla if deve produzir um resultado boolean.

```java
if (condi√ß√£o) {
	sequ√™ncia de instru√ß√µes
} else {
	sequ√™ncia de instru√ß√µes
}
```

## Estrutura Condicional IF-ELSE-IF

Um *if aninhado* √© uma instru√ß√£o if que √© alvo de outro if ou else. Os ifs aninhados s√£o muito comuns em programa√ß√£o. O importante a lembrar sobre ifs aninhados em Java √© o fato de que uma instru√ß√£o else ser√° sempre referente √† instru√ß√£o if mais pr√≥xima que estiver dentro do mesmo bloco e ainda n√£o estiver associada a um else.

Nesta estrutura, as express√µes condicionais s√£o avaliadas de cima para baixo. Assim que uma condi√ß√£o verdadeira √© encontrada, a instru√ß√£o associada a ela √© executada e o resto da escada √© ignorado. Se nenhuma das condi√ß√µes for verdadeira, a instru√ß√£o else final ser√° executada. Com frequ√™ncia, o else final age como uma condi√ß√£o padr√£o, isto √©, se todos os outros testes condicionais falharem, a √∫ltima instru√ß√£o else ser√° executada. Se n√£o houver um else final e todas as outras condi√ß√µes forem falsas, n√£o ocorrer√° nenhuma a√ß√£o.

```java
if(condi√ß√£o){
	sequ√™ncia de instru√ß√µes
} else if(condi√ß√£o){
	sequ√™ncia de instru√ß√µes
} else {
	sequ√™ncia de instru√ß√µes
}
```

## Estrutura de Sele√ß√£o SWITCH

A instru√ß√£o *switch* fornece uma ramifica√ß√£o com v√°rios caminhos. Logo, ela permite que o programa fa√ßa uma sele√ß√£o entre v√°rias alternativas. Funciona desta forma: o valor de uma express√£o √© verificado sucessivamente em uma lista de constantes. Quando uma ocorr√™ncia √© encontrada, a sequ√™ncia de instru√ß√µes associada a essa ocorr√™ncia √© executada.

```java
switch(express√£o){
	case constante1:
		sequ√™ncia de instru√ß√µes
		break;
	case constante2:
		sequ√™ncia de instru√ß√µes
		break;
	case constante3:
		sequ√™ncia de instru√ß√µes
		break;
	default:
		sequ√™ncia de instru√ß√µes
}
```

Cada valor especificado nas instru√ß√µes *case* deve ser uma express√£o de constante exclusiva (como um valor literal). N√£o s√£o permitidos valores duplicados em case. J√° a sequ√™ncia de instru√ß√µes *default* √© opcional: se n√£o estiver presente, n√£o ocorrer√° nenhuma a√ß√£o quando todas as compara√ß√µes falharem. Quando uma ocorr√™ncia √© encontrada, as instru√ß√µes associadas a esse case s√£o executadas at√© break ser alcan√ßado ou, no caso de default ou do √∫ltimo case, at√© o fim de switch ser alcan√ßado. 

Tecnicamente, a instru√ß√£o *break* √© opcional, embora seja usada na maioria das aplica√ß√µes de switch. Quando encontrada dentro da sequ√™ncia de instru√ß√µes de um case, a instru√ß√£o break faz o fluxo do programa sair da instru√ß√µes switch e continuas na pr√≥xima instru√ß√£o externa. No entanto, se uma instru√ß√£o break n√£o terminar a sequ√™ncia de instru√ß√µes associada a um case, tanto as instru√ß√µes pertencentes ao case quanto as posteriores ser√£o executadas at√© um break (ou o fim do switch) ser alcan√ßado.

√â poss√≠vel um switch fazer parte da sequ√™ncia de instru√ß√µes de um switch externo. Isso √© chamado de *switch aninhado*. Mesmo se as constantes case do switch interno e externo tiverem valores comuns, n√£o ocorrer√° conflito.

## Estrutura de Repeti√ß√£o FOR

Em um la√ßo de repeti√ß√£o *for*, a inicializa√ß√£o define uma vari√°vel de controle para inicializar o loop. Na sequ√™ncia, a condi√ß√£o √© uma express√£o booleana que testa a vari√°vel de cotrole do la√ßo. Se o resultado for verdadeiro, o la√ßo for continuar√° a iterar. Se for falso, o la√ßo ser√° encerrado. A express√£o de itera√ß√£o determina como a vari√°vel de la√ßo √© alterada sempre que o la√ßo itera.

```java
for(inicializa√ß√£o; condi√ß√£o; itera√ß√£o){
	sequ√™ncia de instru√ß√µes
}
```

Nesse la√ßo √© poss√≠vel separar tanto instru√ß√µes de inicializa√ß√£o quanto de itera√ß√£o por v√≠rgula, o que significa que n√£o necessariamente uma √∫nica express√£o seja obrigat√≥ria nessas etapas. √â poss√≠vel ter m√∫ltiplas instru√ß√µes de inicializa√ß√£o e itera√ß√£o, mas, na pr√°tica, mais de duas ou tr√™s tornam o la√ßo for dif√≠cil de controlar.

Al√©m disso, √© permitido deixar algumas ou todas as partes referentes √† inicializa√ß√£o, condi√ß√£o ou itera√ß√£o do la√ßo for em branco.

```java
for(i = 0; i < 10; ) {
	System.out.println("Pass #" + i);
	i++; // incremento da vari√°vel de controle no escopo
}
```

Um *la√ßo infinito* pode ser criado da seguinte forma:

```java
for( ; ; ) {
}
```

Loops for tamb√©m podem ser utilizados sem corpo, ou seja, sem instru√ß√µes definidas em diversas linhas. Isso porque o campo de itera√ß√£o pode ser utilizado para sumarizar o c√≥digo.

```java
for(i = 1; i <= 5; sum += i++);
```

## Estrutura FOR-EACH

TBA

## Estrutura de Repeti√ß√£o WHILE

```java
while(condi√ß√£o) {
	sequ√™ncia de instru√ß√µes
}
```

Nesse caso, a condi√ß√£o define o la√ßo, podendo ser qualquer express√£o booleana v√°lida. Enquanto a condi√ß√£o for verdadeira, o la√ßo ser√° repetido. Quando a condi√ß√£o se torna falsa, o controle do programa passa para a linha imediatamente posterior ao la√ßo.

## Estrutura de Repeti√ß√£o DO-WHILE

O la√ßo *do-while* verifica sua condi√ß√£o no fim do la√ßo, ou seja, um la√ßo do-while ser√° sempre executado pelo menos uma vez. E, posteriormente, ser√° executado enquanto a express√£o condicional for verdadeira.

```java
do {
	sequ√™ncia de instru√ß√µes
} while(condi√ß√£o);
```

## BREAK

Quando uma instru√ß√£o *break* √© encontrada dentro de um la√ßo, este √© encerrado e o controle do programa √© retomado na instru√ß√£o posterior ao la√ßo. Quando usada dentro de um conjunto de la√ßos aninhados, a instru√ß√£o break encerra apenas o la√ßo mais interno.

## CONTINUE

A instru√ß√£o *continue* for√ßa a ocorr√™ncia da pr√≥xima itera√ß√£o do la√ßo e qualquer c√≥digo existente entre ela e a express√£o condicional que controla o la√ßo √© ignorado.

```java
for(i = 0; i <= 100; i++){
	if((i % 2) != 0) continue;
	System.out.println(i);
}
```

## RETURN

O encerramento imediato de um m√©todo *void* pode ser realizado usando o **return**:

```java
return ;
```

A exist√™ncia de muitos pontos de sa√≠da em um m√©todo pode desestruturar o c√≥digo, logo √© bom evitar de us√°-los casualmente. Assim, um m√©todo void pode retornar de uma entre duas maneiras: sua chave de fechamento √© alcan√ßada o uma instru√ß√£o return √© executada.

Os valores de retorno s√£o usados para v√°rios fins em programa√ß√£o.

```java
return valor;
```

Essa forma de return s√≥ pode ser usada com m√©todos que tenham tipo de retorno diferente de void.

Podemos passar um ou mais valores para um m√©todo quando ele √© chamado (argumento). Dentro do m√©todo, a vari√°vel que recebe o argumento se chama **par√¢metro**. Os par√¢metros s√£o declarados dentro dos par√™nteses que v√™m ap√≥s o nome do m√©todo.

### üîó Refer√™ncias

-  **Chapter II:** An Overview of Java (*Java - The Complete Reference* 9th Edition by *Herbert Schildt*).
-  **Chapter V:** Control Statements (*Java - The Complete Reference* 9th Edition by *Herbert Schildt*).
-  **Chapter VI:** Introducing Classes (*Java - The Complete Reference* 9th Edition by *Herbert Schildt*).